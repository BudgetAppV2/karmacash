{
  "tasks": [
    {
      "id": "CKA.1",
      "title": "CKA.1 - Initialize Python Project for CK Assistant",
      "description": "Set up the fundamental Python project directory structure, virtual environment, and initial empty files for the CK Assistant modules.\n\nDetails:\n- Create a new root directory for the CK Assistant project (e.g., `ck_assistant_py`).\n- Initialize a Python virtual environment (e.g., using `venv`: `python -m venv .venv` and activate it).\n- Create a `requirements.txt` file and add initial potential dependencies:\n  - `google-generativeai` (for Gemini API)\n  - `requests` (for HTTP calls to Template Exchange API)\n  - `python-dotenv` (for managing API keys via .env file)\n- Install these initial dependencies (`pip install -r requirements.txt`).\n- Create initial empty Python files/directories for the modules suggested by Firebase Studio's Gemini:\n  - `main.py` (Main script/entry point)\n  - `config_loader.py` (Configuration Module)\n  - `gemini_interaction.py` (Gemini Interaction Module)\n  - `template_exchange_client.py` (Template Exchange API Client Module)\n  - (Optional for now) `context_loader.py` (Context Loading Module)\n- Create a `.gitignore` file with common Python ignores (e.g., `.venv/`, `__pycache__/`, `*.pyc`, `.env`).\n- Initialize a local Git repository in this new project directory (`git init`).",
      "status": "pending",
      "priority": "high",
      "dependencies": [],
      "subtasks": [],
      "test_strategy": "- Confirm virtual environment is active and can import installed packages (e.g., `import google.generativeai`).\n- Confirm directory structure and empty module files are created as specified.\n- Confirm `.gitignore` is present and `git status` shows a clean working tree after initial commit.\n- Confirm `main.py` can be run (e.g., with a simple print statement) without errors."
    },
    {
      "id": "CKA.2",
      "title": "CKA.2 - Implement Configuration Module for API Keys & Endpoints",
      "description": "Develop the Configuration Module (`config_loader.py`) to securely load API keys (Gemini, Template Exchange) and the Template Exchange API base URL from environment variables or a `.env` file.\n\nDetails:\n- In `config_loader.py`, implement functions/logic to:\n  - Load environment variables using the `python-dotenv` library from a `.env` file.\n  - Specifically load:\n    - `GEMINI_API_KEY`\n    - `TEMPLATE_EXCHANGE_API_KEY` (this is the `x-api-key` for your existing API)\n    - `TEMPLATE_EXCHANGE_BASE_URL` (the base URL for your Cloud Function API, e.g., `https://YOUR_REGION-YOUR_PROJECT.cloudfunctions.net/api`)\n- Provide clear error handling if any required configuration variable is missing (e.g., raise an exception or log an error and exit).\n- Create a `.env.example` file in the project root that lists the required environment variables without their actual values (e.g., `GEMINI_API_KEY=\"YOUR_GEMINI_API_KEY_HERE\"`).\n- Add `.env` to the `.gitignore` file (already done in CKA.1 if followed, but double-check) to prevent accidental commits of secret keys.\n- The module should make these configuration values easily accessible to other parts of the CK Assistant application (e.g., via functions like `get_gemini_key()`, `get_template_api_key()`, `get_template_api_url()`).",
      "status": "pending",
      "priority": "high",
      "dependencies": [],
      "subtasks": [],
      "test_strategy": "- Create a `.env` file with dummy (or real, for local testing only) API keys and URL.\n- Write a small test script or add test calls in `main.py` to import `config_loader.py` and verify that:\n  - It correctly loads the values from the `.env` file.\n  - It handles missing variables gracefully (e.g., test by temporarily renaming a variable in `.env` and see if the error handling works).\n- Confirm that API keys are not hardcoded in `config_loader.py` or other source files."
    },
    {
      "id": "CKA.3",
      "title": "CKA.3 - Develop Template Exchange API Client Module",
      "description": "Implement the `template_exchange_client.py` module with Python functions to interact with the existing Template Exchange API (Cloud Function endpoints) for creating/updating and retrieving templates.\n\nDetails:\n- In `template_exchange_client.py`:\n  - Import necessary libraries (e.g., `requests`, and the `config_loader` module from CKA.2 to get API URL and key).\n  - Implement `create_or_update_template_api(session_id, template_type, content, status='draft', metadata=None)` function:\n    - This function will be called by the Gemini interaction logic when Gemini wants to store a handoff or summary.\n    - Construct the JSON payload as per `/api/templates` POST endpoint in `api-reference.md`:\n      ```json\n      {\n        \"sessionId\": session_id, // e.g., \"M5.S4\"\n        \"type\": template_type,   // \"handoff\" or \"summary\"\n        \"content\": content,      // Markdown string\n        \"status\": status,        // \"draft\", \"active\", \"archived\"\n        \"metadata\": metadata     // Optional dictionary\n      }\n      ```\n    - Make a `POST` request to `TEMPLATE_EXCHANGE_BASE_URL + \"/templates\"`.\n    - Include the `x-api-key: YOUR_TEMPLATE_EXCHANGE_API_KEY` header.\n    - Handle the HTTP response:\n      - Check for success status codes (e.g., 201 Created).\n      - Parse the JSON response (e.g., to get the created template ID).\n      - Implement robust error handling for API errors (4xx, 5xx status codes), network issues. Log errors and return a clear success/failure indication or the response data/error message.\n  - Implement `get_template_api(session_id, template_type='handoff')` function:\n    - This function will be called by the Gemini interaction logic when Gemini wants to fetch a template.\n    - Make a `GET` request to `TEMPLATE_EXCHANGE_BASE_URL + \"/templates/\" + session_id + \"?type=\" + template_type` (as per `api-reference.md`).\n    - Include the `x-api-key` header.\n    - Handle the HTTP response:\n      - Check for success (200 OK).\n      - Parse JSON response to get template content.\n      - Handle errors (e.g., 404 Not Found if template doesn't exist, other API/network errors). Log errors and return template data or None/error indication.\n  - (Optional, consider later) Implement functions for other API endpoints if needed (e.g., `list_templates_api`, `update_template_by_id_api`, `delete_template_api` from `api-reference.md`). Start with create/get.\n- Ensure all functions properly use the API base URL and API key loaded via the `config_loader` module.",
      "status": "pending",
      "priority": "high",
      "dependencies": [],
      "subtasks": [],
      "test_strategy": "- Unit/Integration Tests (can be manual initially using a test script):\n  - Test `create_or_update_template_api`:\n    - Call with valid data; verify a 201 response and that data appears in your Firebase Firestore `ai_handoffs` collection (check manually in Firebase Console).\n    - Call with missing required fields; verify a 400 Bad Request response from your API.\n    - Call with an invalid API key; verify a 401 Unauthorized response.\n  - Test `get_template_api`:\n    - After creating a template, try to fetch it by `sessionId` and `type`; verify correct content is returned.\n    - Try to fetch a non-existent template; verify a 404 Not Found response.\n    - Test with an invalid API key; verify 401 Unauthorized.\n- Ensure proper error logging is implemented for failed API calls."
    },
    {
      "id": "CKA.4",
      "title": "CKA.4 - Define Gemini Function Declarations for Template Exchange API",
      "description": "In `gemini_interaction.py`, create the Gemini `FunctionDeclaration` objects that describe the Template Exchange API operations (creating/updating and getting templates) so the Gemini model can request these actions.\n\nDetails:\n- In `gemini_interaction.py`:\n  - Import `FunctionDeclaration` and `Tool` from the `google.generativeai.types` (or directly `google.generativeai` depending on SDK version).\n  - Define a `FunctionDeclaration` for creating/updating a template:\n    - Name: e.g., `store_template_in_firebase` (this is the name Gemini will use in its `function_call`).\n    - Description: A clear description for Gemini, e.g., \"Stores or updates a handoff or summary template in the Firebase Template Exchange system for a given session.\"\n    - Parameters (as a JSON schema object):\n      - `sessionId` (type: string, description: \"Session ID, e.g., 'M5.S4'\", required)\n      - `type` (type: string, description: \"Template type, either 'handoff' or 'summary'\", enum: [\"handoff\", \"summary\"], required)\n      - `content` (type: string, description: \"The Markdown content of the template.\", required)\n      - `status` (type: string, description: \"Status of the template, e.g., 'draft', 'active'. Defaults to 'draft'.\", optional)\n      - `metadata` (type: object, description: \"Optional metadata dictionary for the template.\", optional, properties could be loosely defined or allow any additionalProperties)\n  - Define a `FunctionDeclaration` for getting a template:\n    - Name: e.g., `fetch_template_from_firebase`.\n    - Description: e.g., \"Retrieves a specific handoff or summary template from the Firebase Template Exchange system for a given session.\"\n    - Parameters (as a JSON schema object):\n      - `sessionId` (type: string, description: \"Session ID, e.g., 'M5.S4'\", required)\n      - `type` (type: string, description: \"Template type, either 'handoff' or 'summary'. Defaults to 'handoff'.\", enum: [\"handoff\", \"summary\"], optional)\n- These function declarations will be used when initializing the Gemini model with tools (covered in CKA.5).\n- Ensure the parameter names and types in these declarations accurately match what your Python functions in `template_exchange_client.py` (from CKA.3) expect as input and what your API (from `api-reference.md`) requires.\n- Refer to the Google Gemini API documentation for the exact syntax of `FunctionDeclaration` and parameter schema definition.",
      "status": "pending",
      "priority": "high",
      "dependencies": [],
      "subtasks": [],
      "test_strategy": "- Review the defined `FunctionDeclaration` objects for correctness against:\n  - The Gemini API documentation for function calling.\n  - The parameters required by your Template Exchange API endpoints (as defined in `api-reference.md` and implemented in CKA.3).\n  - The expected inputs of the Python functions in `template_exchange_client.py`.\n- This task is primarily about defining data structures; direct execution testing comes in CKA.5 when these are used with the model.\n- A simple test could be to instantiate these `FunctionDeclaration` objects in a Python script to ensure no syntax errors."
    },
    {
      "id": "CKA.5",
      "title": "CKA.5 - Implement Gemini Interaction Module & Function Calling Logic",
      "description": "Develop the `gemini_interaction.py` module to initialize the Gemini model, send it prompts (with context and defined tools/functions), and process its responses, including executing function calls via the Template Exchange API Client.\n\nDetails:\n- In `gemini_interaction.py`:\n  - Import necessary libraries: `google.generativeai` as `genai`, the function declarations from CKA.4, the API client functions from CKA.3 (`template_exchange_client.py`), and config from CKA.2 (`config_loader.py`).\n  - Implement `initialize_gemini_model()` function:\n    - Retrieve `GEMINI_API_KEY` using `config_loader`.\n    - Configure `genai` with the API key.\n    - Get a generative model instance (e.g., `genai.GenerativeModel('gemini-1.5-pro-latest')` or another suitable model).\n    - Create a `Tool` object containing the list of `FunctionDeclaration` objects defined in CKA.4 (e.g., `store_template_in_firebase`, `fetch_template_from_firebase`).\n    - Return the initialized model configured with the `Tool`.\n  - Implement `generate_llm_response(model, prompt_text, chat_history=None)` function:** (This will be the main interaction point)\n    - Takes the initialized `model`, `prompt_text` (from HD or Context Loader), and an optional `chat_history` (for multi-turn conversations).\n    - Sends the content (prompt + history) to the model using `model.generate_content(..., tools=[the_tool_object_created_earlier])`.\n    - Process the `response` from `model.generate_content()`:\n      - Check if `response.candidates[0].content.parts[0].function_call` exists.\n      - If a `function_call` exists:\n        - Extract `function_name` and `args` (arguments dictionary).\n        - Conditionally execute the corresponding Python function from `template_exchange_client.py` (CKA.3) based on `function_name`:\n          - If `function_name == 'store_template_in_firebase'`: Call `template_exchange_client.create_or_update_template_api(**args)`.\n          - If `function_name == 'fetch_template_from_firebase'`: Call `template_exchange_client.get_template_api(**args)`.\n        - Prepare a `FunctionResponse` part: Create a `Part` object containing the result (success/failure, data) from your API client function.\n        - Send this `FunctionResponse` back to the Gemini model by calling `model.generate_content()` again, this time including the original prompt/history and the new `FunctionResponse` part in the `contents`.\n        - The model will then generate a final natural language response based on the function's output. Return this final text.\n      - If no `function_call` (i.e., a direct text response):\n        - Extract and return `response.text`.\n    - Handle potential errors during API calls to Gemini.\n- This module should not contain hardcoded prompts for specific tasks (like \"generate handoff for X\"); that will be handled by the Main Script (CKA.6) or Context Loader (CKA.7). This module provides the *mechanism* for LLM interaction and function execution.\n- Refer to Google Gemini API documentation for `generate_content`, handling `FunctionCall` parts, and sending `FunctionResponse` parts.",
      "status": "pending",
      "priority": "high",
      "dependencies": [],
      "subtasks": [
        {
          "id": "CKA.5.1",
          "title": "Import Libraries and Set Up Module Structure",
          "description": "Import necessary libraries and set up the basic structure of the `gemini_interaction.py` module.\n\nDetails:\n- Import required libraries:\n  - `google.generativeai` as `genai` for the Gemini API\n  - `config_loader` module from CKA.2 for accessing API keys\n  - Function declarations from CKA.4\n  - API client functions from `template_exchange_client.py` (CKA.3)\n- Create the module structure with proper docstrings and type annotations\n- Implement helper functions and constants that will be used across the module",
          "status": "pending",
          "priority": "high",
          "dependencies": [],
          "test_strategy": "- Verify that the module imports all necessary libraries without errors\n- Check that the module structure follows best practices for Python modules\n- Confirm that helper functions and constants are well-documented with proper type annotations"
        },
        {
          "id": "CKA.5.2",
          "title": "Implement Gemini Model Initialization Function",
          "description": "Implement the `initialize_gemini_model()` function to set up and configure the Gemini AI model with the appropriate API key and tools.\n\nDetails:\n- Create the `initialize_gemini_model()` function that:\n  - Retrieves the `GEMINI_API_KEY` using the `config_loader` module\n  - Configures the Gemini API with the key using `genai.configure(api_key=api_key)`\n  - Creates a generative model instance with an appropriate model name (e.g., `gemini-1.5-pro-latest`)\n  - Retrieves the function declarations defined in CKA.4\n  - Creates a `Tool` object containing these function declarations\n  - Configures the model with the tool\n  - Returns the initialized model\n- Include error handling for cases where the API key is missing or invalid\n- Add logging for initialization steps and potential issues",
          "status": "pending",
          "priority": "high",
          "dependencies": [],
          "test_strategy": "- Test initialization with a valid API key\n- Test initialization with a missing API key to verify error handling\n- Verify that the model is correctly configured with the function declarations\n- Check that logging provides appropriate information about the initialization process"
        },
        {
          "id": "CKA.5.3",
          "title": "Implement Base Response Generation Function",
          "description": "Implement the core `generate_llm_response()` function that sends prompts to Gemini and processes the initial response.\n\nDetails:\n- Create the `generate_llm_response(model, prompt_text, chat_history=None)` function that:\n  - Takes the initialized Gemini model, prompt text, and optional chat history\n  - Formats the content correctly for Gemini, including prompt and history if provided\n  - Sends the content to Gemini using `model.generate_content()`\n  - Adds appropriate error handling for API rate limits, network issues, etc.\n  - Returns the response object for further processing\n- Implement basic response handling for direct text responses (non-function calls)\n- Add logging of prompts sent and responses received (excluding sensitive data)",
          "status": "pending",
          "priority": "high",
          "dependencies": [],
          "test_strategy": "- Test with simple prompts that generate direct text responses\n- Verify that responses are correctly processed and returned\n- Test error handling with simulated API errors\n- Check that chat history is correctly incorporated if provided"
        },
        {
          "id": "CKA.5.4",
          "title": "Implement Function Call Detection and Extraction",
          "description": "Add logic to detect and extract function calls from Gemini responses.\n\nDetails:\n- Extend `generate_llm_response()` to:\n  - Check if the response contains a function call (i.e., `response.candidates[0].content.parts[0].function_call` exists)\n  - Extract the function name and arguments from the function call\n  - Validate that the function name matches one of the supported functions\n  - Parse and validate the function arguments\n  - Log details about the detected function call\n- Create helper functions for extracting and validating function calls\n- Handle edge cases like multiple function calls or malformed function calls",
          "status": "pending",
          "priority": "high",
          "dependencies": [],
          "test_strategy": "- Test with prompts that trigger function calls\n- Verify that function calls are correctly detected and extracted\n- Test with invalid function calls to verify error handling\n- Check that the extracted function name and arguments match the expected values"
        },
        {
          "id": "CKA.5.5",
          "title": "Implement Function Execution Logic",
          "description": "Implement the logic to execute the appropriate API client function based on the detected function call.\n\nDetails:\n- Create a function execution handler that:\n  - Takes the extracted function name and arguments\n  - Maps the function name to the corresponding API client function:\n    - `store_template_in_firebase` → `template_exchange_client.create_or_update_template_api()`\n    - `fetch_template_from_firebase` → `template_exchange_client.get_template_api()`\n  - Executes the function with the provided arguments\n  - Captures the result (success/failure, data) from the API client function\n  - Formats the result as a `FunctionResponse` object\n  - Handles and logs any errors that occur during function execution",
          "status": "pending",
          "priority": "high",
          "dependencies": [],
          "test_strategy": "- Test execution of each supported function\n- Verify that the correct API client function is called with the correct arguments\n- Test error handling during function execution\n- Check that the function response is correctly formatted"
        },
        {
          "id": "CKA.5.6",
          "title": "Implement Function Response Handling and Final Response Generation",
          "description": "Complete the function calling flow by sending function responses back to Gemini and generating the final response.\n\nDetails:\n- Extend `generate_llm_response()` to:\n  - Create a `FunctionResponse` part containing the result from the executed function\n  - Send this `FunctionResponse` back to Gemini by calling `model.generate_content()` again\n  - Include the original prompt/history and the new `FunctionResponse` in the `contents`\n  - Process the final response from Gemini\n  - Extract and return the final natural language response\n- Add comprehensive error handling for the entire function calling flow\n- Implement cleanup and logging for the completed process",
          "status": "pending",
          "priority": "high",
          "dependencies": [],
          "test_strategy": "- Test the complete function calling flow from initial prompt to final response\n- Verify that the function response is correctly sent back to Gemini\n- Test that Gemini generates an appropriate final response based on the function result\n- Check error handling throughout the process\n- Verify that the final response is correctly returned to the caller"
        }
      ],
      "test_strategy": "- Create test prompts that are likely to trigger each defined function call.\n- In a test script (or `main.py`):\n  - Initialize the model using `initialize_gemini_model()`.\n  - Call `generate_llm_response()` with a test prompt (e.g., \"Please store a handoff for session M0.S1 with content 'Test handoff content'. The type is 'handoff'.\").\n  - Verify (using mocks for the `template_exchange_client` initially, then with live API calls):\n    - That the correct `function_call` is received from Gemini.\n    - That the appropriate `template_exchange_client` function is called with the correct arguments extracted from `args`.\n    - That a `FunctionResponse` is correctly constructed and sent back to Gemini.\n    - That Gemini's final natural language response reflects the outcome of the function call (e.g., \"Okay, I've stored the handoff...\" or \"Sorry, I couldn't store the handoff because...\").\n  - Test with prompts that should *not* trigger function calls to ensure direct text responses are handled.\n- Test error handling for Gemini API issues.",
      "complexityScore": 7
    },
    {
      "id": "CKA.6",
      "title": "CKA.6 - Develop Main Script for CK Assistant User Interaction",
      "description": "Create the main executable Python script (`main.py`) that initializes the CK Assistant, handles user input (e.g., from the command line), orchestrates calls to the Gemini Interaction Module, and displays results.\n\nDetails:\n- In `main.py`:\n  - Import necessary modules: `config_loader` (CKA.2), `gemini_interaction` (CKA.5), and potentially `context_loader` (CKA.7, if implemented).\n  - Initialization Phase:\n    - Load configuration using `config_loader`.\n    - Initialize the Gemini model using `gemini_interaction.initialize_gemini_model()`.\n    - (If using chat history for multi-turn) Initialize an empty chat history list.\n  - Main Interaction Loop (e.g., a `while True` loop for command-line interaction):\n    - Prompt the user for input (e.g., `input(\"HD > \")`).\n    - Handle exit commands (e.g., if user types \"quit\" or \"exit\").\n    - Context Preparation (Simplified for now, enhanced by CKA.7 later):\n      - For now, the user's input text will be the primary prompt.\n      - (Future: Integrate `context_loader` to fetch SHIP content, TM details, etc., based on user input or pre-defined rules, and prepend this context to the user's direct prompt).\n    - Call Gemini Interaction Module:\n      - Pass the prepared prompt (and chat history, if applicable) to `gemini_interaction.generate_llm_response(model, user_prompt, chat_history)`.\n    - Display Results:\n      - Print the final natural language response received from `generate_llm_response()` to the console.\n      - (If `generate_llm_response` also returns structured data from function calls, decide how/if to display that raw data for debugging).\n    - (If using chat history) Append the user's prompt and the model's final response to the `chat_history` list.\n  - Implement basic error handling for issues during initialization or interaction.\n- This script will be the primary way the HD interacts with the CK Assistant initially.\n- Keep the initial version simple, focusing on the core loop of input -> process -> output.",
      "status": "pending",
      "priority": "high",
      "dependencies": [],
      "subtasks": [],
      "test_strategy": "- Run `python main.py` from the terminal.\n- Test basic interaction:\n  - Enter a simple greeting or question that doesn't require function calling; verify a text response from Gemini.\n  - Enter a prompt designed to trigger a function call (e.g., \"Store a handoff for M0.S0 type handoff with content 'hello world'\"). Verify that:\n    - The `main.py` script calls `gemini_interaction.generate_llm_response()`.\n    - The interaction module processes the function call (as tested in CKA.5).\n    - `main.py` displays Gemini's final natural language response (e.g., \"Okay, I've stored the handoff...\").\n- Test the exit command.\n- Test basic error handling (e.g., if API keys are not set, does it fail gracefully during initialization?).\n- (If chat history is implemented) Test a short multi-turn conversation to see if context is maintained."
    },
    {
      "id": "CKA.7",
      "title": "CKA.7 - Implement Context Loading Module",
      "description": "Develop the `context_loader.py` module to read content from specified project files (e.g., SHIP documents, Bible sections, Task Master task details) and format it as context for Gemini prompts.\n\nDetails:\n- In `context_loader.py`:\n  - Implement `load_ship_document(session_id)` function:\n    - Takes a `session_id` (e.g., \"M5.S4\").\n    - Constructs the SHIP filename (e.g., `Session Handoff & Initialization Plan_M5.NavUX-S4.md`).\n    - Reads the content of the specified SHIP markdown file.\n    - Returns the file content as a string, or None/error if not found.\n  - Implement `load_task_master_task_details(task_id)` function:\n    - Takes a `task_id` (e.g., \"TM#205\").\n    - Option 1 (Simpler): Assume for now it could read from a pre-exported individual markdown task file (e.g., `tasks/TM-205.md`) if that's part of your workflow.\n    - Option 2 (More Robust): Parse `tasks.json` to find the task object by ID and extract its description, details, test strategy, etc., formatting them into a string. (This could be a later enhancement if too complex initially).\n    - Returns the formatted task details as a string, or None/error.\n  - Implement `load_bible_section(bible_ref)` function:\n    - Takes a `bible_ref` (e.g., \"B6.1\" or \"B3.8_Style_Guide_v2.md\").\n    - Constructs the Bible filename (e.g., `docs/B6.1_Budget_Calculations.md`).\n    - Reads the content of the specified Bible markdown file.\n    - Returns the file content as a string, or None/error.\n  - Implement `assemble_prompt_context(ship_content=None, task_details_content=None, bible_sections_content=None, user_query=\"\")` function:\n    - Takes various context strings and the user's direct query.\n    - Assembles them into a single formatted string suitable for a Gemini prompt (e.g., clearly demarcating sections: \"=== SHIP Context ===\\n{ship_content}\\n=== Task Details ===\\n{task_details_content}\\n=== User Query ===\\n{user_query}\").\n- The `main.py` script (from CKA.6) will need to be updated to:\n  - Call these context loading functions based on the user's request (e.g., if the user says \"Generate handoff for TM#205 for SHIP M5.S4 using B6.1\", it would parse these and call the loaders).\n  - Pass the assembled context to `gemini_interaction.generate_llm_response()`.\n- Implement error handling for file not found, read errors, etc.\n- Paths to documentation (SHIPs, Bible, tasks) might need to be configurable (e.g., via `config_loader.py` or relative to the project root).",
      "status": "pending",
      "priority": "medium",
      "dependencies": [],
      "subtasks": [],
      "test_strategy": "- Create dummy SHIP, Task Master task, and Bible files in expected locations with known content.\n- Write test calls (e.g., in a test script or `main.py`) for each loading function:\n  - Verify `load_ship_document()` returns the correct content for a valid session ID.\n  - Verify `load_task_master_task_details()` returns correct content for a valid task ID.\n  - Verify `load_bible_section()` returns correct content for a valid Bible reference.\n  - Test error handling (e.g., what happens if a file is missing?).\n- Test `assemble_prompt_context()` to ensure it correctly combines different context parts into a well-formatted string.\n- Verify that `main.py` (after modification) can successfully use this module to build context and pass it to Gemini."
    },
    {
      "id": "CKA.8",
      "title": "CKA.8 - CK Assistant Testing, Refinement, and Initial Prompt Engineering",
      "description": "Conduct thorough testing of the entire CK Assistant application, refine its components based on test results, and perform initial prompt engineering for core CK tasks (e.g., generating handoffs).\n\nDetails:\n- Component Testing (Unit/Integration):\n  - Revisit and expand tests for `config_loader.py` (CKA.2), `template_exchange_client.py` (CKA.3), `gemini_interaction.py` (CKA.5), and `context_loader.py` (CKA.7).\n  - Use mocking frameworks (e.g., Python's `unittest.mock`) to isolate components and simulate API responses (both success and error cases for Gemini API and Template Exchange API).\n- End-to-End Flow Testing (via `main.py`):\n  - Test various user commands/prompts that trigger different functionalities:\n    - Storing a handoff.\n    - Storing a summary.\n    - Fetching a handoff.\n    - Fetching a summary.\n    - Interactions that don't require function calls (general Q&A with Gemini, if supported by base prompts).\n  - Verify that context (from SHIP, TM, Bible) is correctly loaded and seems to influence Gemini's responses when context loading is used.\n  - Verify that the final output (e.g., generated handoff text, retrieved summary) is accurate.\n  - Verify that data is correctly stored/retrieved from Firebase (manual check in console + API responses).\n- Prompt Engineering (Initial Pass):\n  - Develop initial \"system prompts\" or prompt templates that will be used by `main.py` or `gemini_interaction.py` to guide Gemini for specific CK tasks.\n  - Example for generating a handoff:\n    ```\n    System Prompt: \"You are a Context Keeper assistant for the KarmaCash project. Based on the provided SHIP document context, Task Master details, and relevant Bible sections, generate a detailed Handoff message for the Code Generator (CG) using the standard Handoff Template (SHIP Section 7). Ensure all sections of the Handoff template are addressed.\"\n    User Query (after context): \"Generate the handoff for task [TM_ID_HERE].\"\n    ```\n  - Experiment with prompt wording to achieve desired output quality and consistency for handoffs and summaries.\n  - Test how well Gemini uses the provided function declarations based on these prompts.\n- Refinement:\n  - Based on testing, refine:\n    - Function declarations (CKA.4) if Gemini is not understanding them well or if parameters need adjustment.\n    - Prompt templates for clarity and effectiveness.\n    - Error handling in all modules.\n    - User interaction flow in `main.py`.\n- Documentation (Internal): Add comments and docstrings to the Python code.",
      "status": "pending",
      "priority": "high",
      "dependencies": [],
      "subtasks": [
        {
          "id": "CKA.8.1",
          "title": "Develop Unit and Integration Tests for Core Modules",
          "description": "Create comprehensive unit and integration tests for each of the core modules (`config_loader.py`, `template_exchange_client.py`, `gemini_interaction.py`, and `context_loader.py`).\n\nDetails:\n- Set up a testing framework (e.g., `unittest` or `pytest`)\n- Create a `tests` directory with appropriate test files for each module\n- Implement unit tests for `config_loader.py`:\n  - Test loading of environment variables\n  - Test error handling for missing variables\n  - Test accessor functions for configuration values\n- Implement unit tests for `template_exchange_client.py`:\n  - Use mocks to simulate API responses for create/update template\n  - Use mocks to simulate API responses for get template\n  - Test error handling for various HTTP error codes\n  - Test handling of network issues\n- Implement unit tests for `gemini_interaction.py`:\n  - Test model initialization\n  - Test response generation with mocked Gemini API\n  - Test function call detection and extraction\n  - Test function execution with mocked API client\n  - Test function response handling\n- Implement unit tests for `context_loader.py`:\n  - Test loading of various document types (SHIP, TM, Bible)\n  - Test error handling for missing files\n  - Test context assembly\n- Implement integration tests that connect multiple modules",
          "status": "pending",
          "priority": "high",
          "dependencies": [],
          "test_strategy": "- Verify that all tests pass successfully\n- Check code coverage to ensure all critical paths are tested\n- Ensure that edge cases and error conditions are properly tested\n- Confirm that mocks are used appropriately to isolate components"
        },
        {
          "id": "CKA.8.2",
          "title": "Develop End-to-End Flow Tests",
          "description": "Create end-to-end tests that verify the complete functionality of the CK Assistant from user input to final output.\n\nDetails:\n- Create test scripts that simulate user interactions with the CK Assistant\n- Test scenarios for storing handoffs:\n  - Create prompts that should trigger handoff storage\n  - Verify that the handoff is correctly stored in Firebase\n  - Check that the response to the user is appropriate\n- Test scenarios for storing summaries:\n  - Create prompts that should trigger summary storage\n  - Verify that the summary is correctly stored in Firebase\n  - Check that the response to the user is appropriate\n- Test scenarios for fetching handoffs:\n  - Create prompts that should trigger handoff retrieval\n  - Verify that the handoff is correctly retrieved from Firebase\n  - Check that the response to the user includes the handoff content\n- Test scenarios for fetching summaries:\n  - Create prompts that should trigger summary retrieval\n  - Verify that the summary is correctly retrieved from Firebase\n  - Check that the response to the user includes the summary content\n- Test scenarios for general Q&A:\n  - Create prompts that should trigger general Q&A (non-function calls)\n  - Verify that the responses are appropriate\n- Test context integration:\n  - Create prompts that include references to SHIP, TM, and Bible documents\n  - Verify that the context is correctly loaded and influences the responses",
          "status": "pending",
          "priority": "high",
          "dependencies": [],
          "test_strategy": "- Execute each test scenario and verify the expected outcomes\n- Check that the end-to-end flow works correctly for each functionality\n- Verify that the integration of all components works as expected\n- Confirm that the user experience is smooth and intuitive"
        },
        {
          "id": "CKA.8.3",
          "title": "Develop Initial Prompt Templates and Conduct Prompt Engineering",
          "description": "Create and refine prompt templates for the CK Assistant to effectively guide Gemini for specific tasks.\n\nDetails:\n- Develop initial system prompts for core CK tasks:\n  - Handoff generation prompt template\n  - Summary generation prompt template\n  - General assistance prompt template\n- Define placeholders for dynamic content (e.g., SHIP, TM, Bible references)\n- Experiment with different prompt wordings and structures to optimize Gemini's responses\n- Document the prompt templates and their intended use cases\n- Test how different prompt formulations affect Gemini's understanding and use of function declarations\n- Develop guidelines for constructing effective prompts for the CK Assistant",
          "status": "pending",
          "priority": "high",
          "dependencies": [],
          "test_strategy": "- Test each prompt template with various inputs\n- Compare the quality and consistency of responses between different prompt formulations\n- Verify that the prompts effectively guide Gemini to use function declarations when appropriate\n- Ensure that the prompts result in well-structured, accurate, and helpful responses"
        },
        {
          "id": "CKA.8.4",
          "title": "Refine Component Implementations Based on Test Results",
          "description": "Analyze test results and refine the implementation of core components to improve robustness, performance, and user experience.\n\nDetails:\n- Review test results from unit, integration, and end-to-end tests\n- Identify and address issues in each component:\n  - `config_loader.py`: Refine error handling and configuration access\n  - `template_exchange_client.py`: Improve API interaction, error handling, and response processing\n  - `gemini_interaction.py`: Enhance function calling logic, response processing, and error recovery\n  - `context_loader.py`: Optimize context loading and assembly\n  - `main.py`: Refine user interaction flow and command processing\n- Implement fixes for identified issues\n- Optimize performance bottlenecks\n- Improve error messages and user feedback\n- Refine function declarations if Gemini is not understanding them well\n- Update tests to reflect the refinements",
          "status": "pending",
          "priority": "high",
          "dependencies": [],
          "test_strategy": "- Re-run tests after each refinement to verify fixes\n- Ensure that refined components continue to pass all tests\n- Verify that identified issues are resolved\n- Confirm that the overall system is more robust and user-friendly"
        },
        {
          "id": "CKA.8.5",
          "title": "Document Module APIs and Usage Examples",
          "description": "Create comprehensive internal documentation for all modules, including API references, usage examples, and best practices.\n\nDetails:\n- Add detailed docstrings to all functions, classes, and modules\n- Create API reference documentation that describes:\n  - Module purpose and functionality\n  - Function signatures, parameters, return values, and exceptions\n  - Class definitions and methods\n  - Usage examples and common patterns\n- Document how the components interact with each other\n- Create usage examples for common scenarios\n- Document known limitations and edge cases\n- Add inline comments for complex logic\n- Ensure documentation follows a consistent style and format",
          "status": "pending",
          "priority": "medium",
          "dependencies": [],
          "test_strategy": "- Review documentation for clarity, accuracy, and completeness\n- Verify that the documentation matches the actual implementation\n- Ensure that all public APIs are properly documented\n- Check that usage examples are accurate and helpful"
        },
        {
          "id": "CKA.8.6",
          "title": "Create Basic User Guide for CK Assistant",
          "description": "Develop a basic user guide for the CK Assistant that explains how to use it effectively for generating and retrieving handoffs and summaries.\n\nDetails:\n- Create a `README.md` file that includes:\n  - Overview of the CK Assistant and its purpose\n  - Installation and setup instructions\n  - Configuration requirements (API keys, etc.)\n  - Basic usage instructions\n  - Command examples for common tasks:\n    - Generating handoffs\n    - Generating summaries\n    - Retrieving handoffs\n    - Retrieving summaries\n    - Using context references (SHIP, TM, Bible)\n  - Troubleshooting tips\n  - Known limitations\n- Include screenshots or terminal examples where helpful\n- Add a FAQ section for common questions\n- Document best practices for effective use of the CK Assistant\n- Provide contact information for support or questions",
          "status": "pending",
          "priority": "medium",
          "dependencies": [],
          "test_strategy": "- Review the user guide for clarity, accuracy, and completeness\n- Verify that all essential information is included\n- Ensure that the instructions are easy to follow\n- Check that the examples are accurate and helpful"
        }
      ],
      "test_strategy": "- Define a checklist of test scenarios covering all core functionalities and edge cases.\n- Document test results, especially for prompt engineering experiments (which prompts work best for which tasks).\n- Ensure the application is reasonably robust before considering it \"v0.1 complete\".\n- Verify that the CK Assistant successfully uses the Template Exchange API to store and retrieve data without errors for common cases.",
      "complexityScore": 8
    }
  ]
}